<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG系统V2.0架构 - 深度交互式学习平台</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            animation: fadeInDown 0.8s;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.95;
        }

        .header .features {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95em;
        }

        .header .features span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 主布局：左侧控制面板，中间流程图，右侧信息面板 */
        .main-layout {
            display: grid;
            grid-template-columns: 320px 1fr 400px;
            gap: 20px;
            margin-bottom: 30px;
            height: calc(100vh - 180px);
            align-items: stretch;
        }

        /* 左侧控制面板 */
        .control-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            height: 100%;
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            color: #2a5298;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mode-btn {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            font-size: 0.95em;
        }

        .mode-btn:hover {
            border-color: #2a5298;
            transform: translateX(5px);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .mode-btn .subtitle {
            font-size: 0.8em;
            opacity: 0.8;
            margin-top: 4px;
        }

        /* 深度学习卡片 */
        .learning-card {
            background: linear-gradient(135deg, #f0f4ff 0%, #e8eeff 100%);
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .learning-card h4 {
            color: #2a5298;
            margin-bottom: 10px;
            font-size: 1.05em;
        }

        .concept-box {
            background: white;
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }

        .concept-box strong {
            color: #667eea;
            display: block;
            margin-bottom: 5px;
        }

        /* 中间流程可视化区域 */
        .flow-visualization {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            position: relative;
            height: 100%;
            overflow-y: auto;
        }

        .stage-title {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
        }

        /* 节点样式 */
        .flow-node {
            fill: #f0f4ff;
            stroke: #667eea;
            stroke-width: 2;
            cursor: pointer;
            transition: all 0.3s;
        }

        .flow-node:hover {
            fill: #e8eeff;
            stroke-width: 3;
            filter: drop-shadow(0 0 10px rgba(102, 126, 234, 0.3));
        }

        .flow-node.active {
            fill: #667eea;
            stroke-width: 3;
            filter: drop-shadow(0 0 10px rgba(102, 126, 234, 0.5));
        }

        .flow-node.completed {
            fill: #d4edda;
            stroke: #28a745;
        }

        .flow-node.clickable {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .node-text {
            fill: #333;
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-text.active {
            fill: white;
            font-weight: bold;
        }

        /* 管道连线 */
        .pipeline-path {
            fill: none;
            stroke: #e0e0e0;
            stroke-width: 3;
            stroke-dasharray: 5, 5;
        }

        .pipeline-path.active {
            stroke: #667eea;
            stroke-dasharray: none;
            animation: pulseStroke 1s infinite;
        }

        @keyframes pulseStroke {
            0%, 100% { stroke-width: 3; }
            50% { stroke-width: 5; }
        }

        /* 右侧信息面板 */
        .info-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            height: 100%;
            overflow-y: auto;
        }

        .info-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .info-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            position: relative;
        }

        .info-tab:hover {
            color: #2a5298;
        }

        .info-tab.active {
            color: #667eea;
            font-weight: 600;
        }

        .info-tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: #667eea;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* 代码块样式 */
        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            margin: 10px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .code-block .keyword {
            color: #569cd6;
        }

        .code-block .string {
            color: #ce9178;
        }

        .code-block .comment {
            color: #6a9955;
        }

        .code-block .function {
            color: #dcdcaa;
        }

        /* 对比表格 */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 10px;
            text-align: left;
            border: 1px solid #e0e0e0;
        }

        .comparison-table th {
            background: #f8f9fa;
            color: #2a5298;
            font-weight: 600;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .comparison-table .check {
            color: #28a745;
        }

        .comparison-table .cross {
            color: #dc3545;
        }

        /* 向量空间可视化 */
        .vector-space-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #e8f4ff 100%);
            border: 2px solid #007bff;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,123,255,0.1);
        }

        .vector-canvas {
            border: 2px solid #007bff;
            border-radius: 12px;
            background: white;
            margin: 15px auto;
            display: block;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        /* 性能指标 */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .metric-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #2a5298;
        }

        .metric-label {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }

        /* 动态右侧面板样式 */
        .node-selected {
            border: 3px solid #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.4);
        }

        .panel-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .panel-section h4 {
            color: #2a5298;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .state-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }

        .state-indicator.dev {
            background: #e3f2fd;
            color: #1976d2;
        }

        .state-indicator.manage {
            background: #fff3e0;
            color: #f57c00;
        }

        .state-indicator.runtime {
            background: #e8f5e8;
            color: #388e3c;
        }

        /* 类比说明框 */
        .analogy-box {
            background: #fffbf0;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .analogy-box h5 {
            color: #856404;
            margin-bottom: 10px;
        }

        .analogy-box .analogy-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
        }

        .analogy-box .icon {
            font-size: 1.5em;
        }

        /* 进度条 */
        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* 响应式设计 */
        @media (max-width: 1600px) {
            .main-layout {
                grid-template-columns: 280px 1fr 350px;
            }
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .control-panel,
            .info-panel {
                max-height: none;
            }
        }

        /* 提示框 */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.9em;
            max-width: 300px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            line-height: 1.4;
        }

        .tooltip.show {
            opacity: 1;
        }

        /* 按钮样式 */
        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-success {
            background: #28a745;
        }

        /* 深度解释面板 */
        .deep-explanation {
            background: #f0f8ff;
            border: 2px solid #2a5298;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .deep-explanation h4 {
            color: #2a5298;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .explanation-section {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }

        .explanation-section h5 {
            color: #667eea;
            margin-bottom: 10px;
        }

        /* 加载动画 */
        .spinner {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #667eea;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 RAG系统V2.0架构 - 深度交互式学习平台</h1>
            <p>点击每个组件深入了解原理、查看代码、观察运行状态</p>
            <div class="features">
                <span>📚 深度教学</span>
                <span>🔍 向量语义搜索</span>
                <span>🤖 双模型架构</span>
                <span>💻 真实代码展示</span>
                <span>⚡ 实时数据流</span>
            </div>
        </div>

        <div class="main-layout">
            <!-- 左侧控制面板 -->
            <div class="control-panel">
                <div class="control-section">
                    <h3>🎮 系统模式</h3>
                    <div class="mode-selector">
                        <button class="mode-btn active" onclick="switchMode('dev', event)">
                            🛠️ 开发态 - 系统配置
                            <div class="subtitle">理解组件初始化原理</div>
                        </button>
                        <button class="mode-btn" onclick="switchMode('manage', event)">
                            📋 管理态 - 文档处理
                            <div class="subtitle">学习向量化过程</div>
                        </button>
                        <button class="mode-btn" onclick="switchMode('runtime', event)">
                            🚀 运行态 - 查询处理
                            <div class="subtitle">体验完整数据流</div>
                        </button>
                    </div>
                </div>

                <!-- 动态学习卡片 - 根据当前状态显示不同内容 -->
                <div class="learning-card" id="context-learning-card">
                    <h4 id="learning-card-title">🎓 为什么用向量数据库？</h4>
                    <div id="learning-card-content">
                        <div class="concept-box">
                            <strong>传统数据库的局限：</strong>
                            只能精确匹配关键词，无法理解语义
                        </div>
                        <div class="concept-box">
                            <strong>向量数据库的优势：</strong>
                            理解"意思相近"的内容，支持语义搜索
                        </div>
                        <div class="analogy-box">
                            <h5>💡 生活类比</h5>
                            <div class="analogy-item">
                                <span class="icon">📚</span>
                                <span>传统DB = 图书馆书名索引</span>
                            </div>
                            <div class="analogy-item">
                                <span class="icon">🧠</span>
                                <span>向量DB = 图书管理员的知识</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 演示控制 -->
                <div class="control-section">
                    <h3>🎮 演示控制</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button class="btn" onclick="startDemo()" id="demo-btn">
                            ▶️ 开始演示
                        </button>
                        <button class="btn btn-secondary" onclick="resetDemo()">
                            🔄 重置
                        </button>
                        <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 0.9em;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span>状态:</span>
                                <span id="status-text" style="color: #28a745; font-weight: bold;">准备就绪</span>
                            </div>
                            <div style="margin-top: 8px;">
                                <div style="background: #e0e0e0; height: 4px; border-radius: 2px;">
                                    <div id="progress-fill" style="background: #28a745; height: 100%; width: 0%; border-radius: 2px; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 中间流程可视化 -->
            <div class="flow-visualization">
                <div class="stage-title" id="stage-title">🛠️ 开发态 - 系统初始化</div>
                
                <!-- 开发态可视化 -->
                <div id="dev-flow" class="flow-content">
                    <svg class="pipeline-svg" viewBox="0 0 900 600" style="width: 100%; height: 500px;">
                        <!-- 配置读取节点 -->
                        <g class="node-group" onclick="showNodeDetail('config')">
                            <rect x="50" y="50" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="config-node"/>
                            <text x="125" y="85" class="node-text">📄 配置读取</text>
                            <text x="125" y="105" class="node-text" style="font-size: 14px;">.env文件</text>
                        </g>
                        
                        <!-- 向量数据库节点 - 可点击了解深度原理 -->
                        <g class="node-group" onclick="showNodeDetail('vectordb')">
                            <rect x="250" y="50" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="vectordb-node"/>
                            <text x="325" y="85" class="node-text">🗄️ 向量数据库</text>
                            <text x="325" y="105" class="node-text" style="font-size: 14px;">ChromaDB</text>
                        </g>
                        
                        <!-- 嵌入模型节点 - 可点击了解MiniLM-L6 -->
                        <g class="node-group" onclick="showNodeDetail('embedding')">
                            <rect x="450" y="50" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="embedding-node"/>
                            <text x="525" y="85" class="node-text">🔢 嵌入模型</text>
                            <text x="525" y="105" class="node-text" style="font-size: 14px;">MiniLM-L6</text>
                        </g>
                        
                        <!-- AI模型配置节点 -->
                        <g class="node-group" onclick="showNodeDetail('ai-config')">
                            <rect x="150" y="200" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="ai-config-node"/>
                            <text x="225" y="235" class="node-text">🤖 AI模型配置</text>
                            <text x="225" y="255" class="node-text" style="font-size: 14px;">DeepSeek双模型</text>
                        </g>
                        
                        <!-- 智能路由器节点 - 可点击了解路由决策 -->
                        <g class="node-group" onclick="showNodeDetail('router')">
                            <rect x="350" y="200" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="router-node"/>
                            <text x="425" y="235" class="node-text">🚦 智能路由器</text>
                            <text x="425" y="255" class="node-text" style="font-size: 14px;">任务分发</text>
                        </g>
                        
                        <!-- 连接线 -->
                        <path d="M200,90 L250,90" class="pipeline-path" id="path1"/>
                        <path d="M400,90 L450,90" class="pipeline-path" id="path2"/>
                        <path d="M325,130 L325,170 L225,170 L225,200" class="pipeline-path" id="path3"/>
                        <path d="M300,240 L350,240" class="pipeline-path" id="path4"/>
                        
                        <!-- 点击提示 -->
                        <text x="450" y="350" style="fill: #667eea; font-size: 14px; text-anchor: middle;">
                            💡 点击任意组件查看详细信息
                        </text>
                    </svg>
                    
                    <!-- MiniLM-L6深度解释 -->
                    <div class="deep-explanation">
                        <h4>🔬 MiniLM-L6模型：文本如何变成向量？</h4>
                        <div class="explanation-section">
                            <h5>1️⃣ 分词（Tokenization）</h5>
                            <p>"Python编程基础" → ["Python", "编程", "基础"]</p>
                        </div>
                        <div class="explanation-section">
                            <h5>2️⃣ 编码（Encoding）</h5>
                            <p>["Python", "编程", "基础"] → [101, 2348, 1523, 102]</p>
                        </div>
                        <div class="explanation-section">
                            <h5>3️⃣ 嵌入（Embedding）</h5>
                            <p>[101, 2348, 1523, 102] → [0.23, -0.45, 0.67, ...] (384维)</p>
                        </div>
                        <div class="code-block">
<span class="comment"># 实际Python代码</span>
<span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer

<span class="comment"># 加载模型（仅25MB，轻量高效）</span>
model = SentenceTransformer(<span class="string">'all-MiniLM-L6-v2'</span>)

<span class="comment"># 文本转向量</span>
text = <span class="string">"Python编程基础"</span>
vector = model.encode(text)  <span class="comment"># 返回384维向量</span>
<span class="keyword">print</span>(f<span class="string">"向量维度: {len(vector)}"</span>)  <span class="comment"># 输出: 384</span>
                        </div>
                    </div>
                </div>

                <!-- 管理态可视化 -->
                <div id="manage-flow" class="flow-content" style="display: none;">
                    <svg class="pipeline-svg" viewBox="0 0 900 600" style="width: 100%; height: 500px;">
                        <!-- 文档处理流程节点 -->
                        <g class="node-group" onclick="showManageNodeDetail('doc-input')">
                            <rect x="50" y="50" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="doc-input-node"/>
                            <text x="125" y="85" class="node-text">📥 文档输入</text>
                            <text x="125" y="105" class="node-text" style="font-size: 14px;">MD/PDF/TXT</text>
                        </g>
                        
                        <g class="node-group" onclick="showManageNodeDetail('doc-parse')">
                            <rect x="250" y="50" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="doc-parse-node"/>
                            <text x="325" y="85" class="node-text">🔍 文档解析</text>
                            <text x="325" y="105" class="node-text" style="font-size: 14px;">提取内容</text>
                        </g>
                        
                        <g class="node-group" onclick="showManageNodeDetail('chunk')">
                            <rect x="450" y="50" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="chunk-node"/>
                            <text x="525" y="85" class="node-text">✂️ 文本分块</text>
                            <text x="525" y="105" class="node-text" style="font-size: 14px;">500字符/块</text>
                        </g>
                        
                        <g class="node-group" onclick="showManageNodeDetail('vectorize')">
                            <rect x="650" y="50" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="vectorize-node"/>
                            <text x="725" y="85" class="node-text">🔢 向量化</text>
                            <text x="725" y="105" class="node-text" style="font-size: 14px;">384维向量</text>
                        </g>
                        
                        <g class="node-group" onclick="showManageNodeDetail('store')">
                            <rect x="350" y="250" width="150" height="80" rx="10" 
                                  class="flow-node clickable" id="store-node"/>
                            <text x="425" y="285" class="node-text">💾 数据存储</text>
                            <text x="425" y="305" class="node-text" style="font-size: 14px;">ChromaDB</text>
                        </g>
                        
                        <!-- 连接线 -->
                        <path d="M200,90 L250,90" class="pipeline-path"/>
                        <path d="M400,90 L450,90" class="pipeline-path"/>
                        <path d="M600,90 L650,90" class="pipeline-path"/>
                        <path d="M725,130 L725,190 L425,190 L425,250" class="pipeline-path"/>
                        
                        <!-- 点击提示 -->
                        <text x="450" y="450" style="fill: #667eea; font-size: 14px; text-anchor: middle;">
                            💡 点击任意组件查看详细信息
                        </text>
                    </svg>
                    
                    <!-- 分块策略解释 -->
                    <div class="deep-explanation">
                        <h4>📐 为什么要分块？如何分块？</h4>
                        <div class="explanation-section">
                            <h5>为什么分块？</h5>
                            <ul>
                                <li>模型输入长度限制（MiniLM-L6最大256 tokens）</li>
                                <li>提高搜索精度（小块更容易匹配）</li>
                                <li>优化存储和检索效率</li>
                            </ul>
                        </div>
                        <div class="explanation-section">
                            <h5>分块策略</h5>
                            <p><strong>块大小：</strong>500字符</p>
                            <p><strong>重叠：</strong>100字符</p>
                            <p><strong>原因：</strong>保持上下文连贯性</p>
                        </div>
                        <div class="code-block">
<span class="comment"># 文档分块实现</span>
<span class="keyword">def</span> <span class="function">chunk_text</span>(text, chunk_size=<span class="number">500</span>, overlap=<span class="number">100</span>):
    chunks = []
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(text), chunk_size - overlap):
        chunk = text[i:i + chunk_size]
        chunks.append(chunk)
    <span class="keyword">return</span> chunks

<span class="comment"># 示例</span>
text = <span class="string">"Python是一种高级编程语言..."</span> * <span class="number">100</span>
chunks = chunk_text(text)
<span class="keyword">print</span>(f<span class="string">"文档被分成 {len(chunks)} 块"</span>)
                        </div>
                    </div>
                    
                    <!-- 向量空间可视化 -->
                    <div class="vector-space-container">
                        <h4>🌌 向量空间可视化</h4>
                        <canvas id="vector-canvas" class="vector-canvas" width="600" height="400"></canvas>
                        <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                            红点：查询向量 | 蓝点：文档向量 | 绿线：相似度连接
                        </p>
                        <div style="margin-top: 15px; padding: 15px; background: #e8f4ff; border-radius: 8px; border-left: 4px solid #007bff;">
                            <p style="margin: 0; font-size: 0.9em; color: #555;">
                                <strong>💡 提示：</strong>这是384维空间在2D平面的投影演示。实际向量计算在高维空间中进行，具有更强的语义表达能力。
                            </p>
                        </div>
                    </div>
                </div>

                <!-- 运行态可视化 -->
                <div id="runtime-flow" class="flow-content" style="display: none;">
                    <svg class="pipeline-svg" viewBox="0 0 1000 800" style="width: 100%; height: 700px;">
                        <!-- 完整的11步流程 -->
                        
                        <!-- Step 1: 用户输入 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('user-input')">
                            <rect x="50" y="50" width="120" height="60" rx="10" 
                                  class="flow-node clickable" id="user-input-node"/>
                            <text x="110" y="75" class="node-text">🔍 用户输入</text>
                            <text x="110" y="95" class="node-text" style="font-size: 14px;">查询问题</text>
                        </g>
                        
                        <!-- Step 2: API接收 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('api-receive')">
                            <rect x="220" y="50" width="120" height="60" rx="10" 
                                  class="flow-node clickable" id="api-receive-node"/>
                            <text x="280" y="75" class="node-text">🌐 API接收</text>
                            <text x="280" y="95" class="node-text" style="font-size: 14px;">FastAPI</text>
                        </g>
                        
                        <!-- Step 3: 会话管理 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('session-mgmt')">
                            <rect x="390" y="50" width="120" height="60" rx="10" 
                                  class="flow-node clickable" id="session-mgmt-node"/>
                            <text x="450" y="75" class="node-text">📋 会话管理</text>
                            <text x="450" y="95" class="node-text" style="font-size: 14px;">上下文</text>
                        </g>
                        
                        <!-- Step 4: 工具准备 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('tool-prep')">
                            <rect x="560" y="50" width="120" height="60" rx="10" 
                                  class="flow-node clickable" id="tool-prep-node"/>
                            <text x="620" y="75" class="node-text">🔧 工具准备</text>
                            <text x="620" y="95" class="node-text" style="font-size: 14px;">格式转换</text>
                        </g>
                        
                        <!-- Step 5: 路由决策 (核心) -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('router-decision')">
                            <rect x="350" y="180" width="180" height="70" rx="10" 
                                  class="flow-node clickable" id="router-decision-node"
                                  style="fill: #fff3cd; stroke: #ffc107; stroke-width: 3;"/>
                            <text x="440" y="210" class="node-text" style="font-weight: bold;">🚦 路由决策</text>
                            <text x="440" y="230" class="node-text" style="font-size: 14px;">智能判断</text>
                        </g>
                        
                        <!-- 左分支: 工具调用路径 -->
                        <!-- Step 6: V3模型 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('model-v3')">
                            <rect x="150" y="320" width="140" height="60" rx="10" 
                                  class="flow-node clickable" id="model-v3-node"
                                  style="fill: #e8f5e8; stroke: #28a745;"/>
                            <text x="220" y="345" class="node-text">🔧 DeepSeek-V3</text>
                            <text x="220" y="365" class="node-text" style="font-size: 14px;">工具调用</text>
                        </g>
                        
                        <!-- Step 7: 工具调用 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('tool-call')">
                            <rect x="150" y="420" width="140" height="60" rx="10" 
                                  class="flow-node clickable" id="tool-call-node"/>
                            <text x="220" y="445" class="node-text">🛠️ 工具调用</text>
                            <text x="220" y="465" class="node-text" style="font-size: 14px;">search_course</text>
                        </g>
                        
                        <!-- Step 8: 向量搜索 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('vector-search')">
                            <rect x="150" y="520" width="140" height="60" rx="10" 
                                  class="flow-node clickable" id="vector-search-node"/>
                            <text x="220" y="545" class="node-text">🔍 向量搜索</text>
                            <text x="220" y="565" class="node-text" style="font-size: 14px;">ChromaDB</text>
                        </g>
                        
                        <!-- 右分支: 直接推理路径 -->
                        <!-- R1直接处理 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('model-r1-direct')">
                            <rect x="590" y="320" width="140" height="60" rx="10" 
                                  class="flow-node clickable" id="model-r1-direct-node"
                                  style="fill: #ffe8e8; stroke: #dc3545;"/>
                            <text x="660" y="345" class="node-text">🧠 DeepSeek-R1</text>
                            <text x="660" y="365" class="node-text" style="font-size: 14px;">直接推理</text>
                        </g>
                        
                        <!-- Step 9: 模型切换 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('model-switch')">
                            <rect x="350" y="420" width="180" height="60" rx="10" 
                                  class="flow-node clickable" id="model-switch-node"
                                  style="fill: #f0f4ff; stroke: #667eea; stroke-width: 2;"/>
                            <text x="440" y="445" class="node-text">🔄 模型切换</text>
                            <text x="440" y="465" class="node-text" style="font-size: 14px;">V3 → R1</text>
                        </g>
                        
                        <!-- Step 10: 结果整合 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('result-integrate')">
                            <rect x="350" y="520" width="180" height="60" rx="10" 
                                  class="flow-node clickable" id="result-integrate-node"
                                  style="fill: #ffe8e8; stroke: #dc3545;"/>
                            <text x="440" y="545" class="node-text">🧩 结果整合</text>
                            <text x="440" y="565" class="node-text" style="font-size: 14px;">R1处理</text>
                        </g>
                        
                        <!-- Step 11: 最终响应 -->
                        <g class="node-group" onclick="showRuntimeNodeDetail('final-response')">
                            <rect x="350" y="620" width="180" height="60" rx="10" 
                                  class="flow-node clickable" id="final-response-node"
                                  style="fill: #d4edda; stroke: #28a745; stroke-width: 3;"/>
                            <text x="440" y="645" class="node-text" style="font-weight: bold;">📤 最终响应</text>
                            <text x="440" y="665" class="node-text" style="font-size: 14px;">返回答案</text>
                        </g>
                        
                        <!-- 连接线 - 主流程 -->
                        <path d="M170,80 L220,80" class="pipeline-path"/>
                        <path d="M340,80 L390,80" class="pipeline-path"/>
                        <path d="M510,80 L560,80" class="pipeline-path"/>
                        <path d="M620,110 L620,150 L440,150 L440,180" class="pipeline-path"/>
                        
                        <!-- 左分支连线 (工具路径) -->
                        <path d="M350,215 L220,215 L220,320" class="pipeline-path" id="tool-path"
                              style="stroke: #28a745; stroke-dasharray: 10,5;"/>
                        <path d="M220,380 L220,420" class="pipeline-path" style="stroke: #28a745;"/>
                        <path d="M220,480 L220,520" class="pipeline-path" style="stroke: #28a745;"/>
                        <path d="M290,550 L350,550" class="pipeline-path" style="stroke: #28a745;"/>
                        
                        <!-- 右分支连线 (直接路径) -->
                        <path d="M530,215 L660,215 L660,320" class="pipeline-path" id="direct-path"
                              style="stroke: #dc3545; stroke-dasharray: 10,5;"/>
                        <path d="M660,380 L660,450 L530,450" class="pipeline-path" style="stroke: #dc3545;"/>
                        
                        <!-- 模型切换连线 -->
                        <path d="M290,350 L350,350 L350,420" class="pipeline-path" 
                              style="stroke: #667eea; stroke-width: 2;"/>
                        <path d="M440,480 L440,520" class="pipeline-path" style="stroke: #dc3545;"/>
                        <path d="M440,580 L440,620" class="pipeline-path" style="stroke: #28a745;"/>
                        
                        <!-- 标注文字 -->
                        <text x="250" y="200" style="fill: #28a745; font-size: 12px;">需要搜索</text>
                        <text x="550" y="200" style="fill: #dc3545; font-size: 12px;">直接回答</text>
                        <text x="320" y="400" style="fill: #667eea; font-size: 12px;">切换模型</text>
                        
                        <!-- 点击提示 -->
                        <text x="500" y="750" style="fill: #667eea; font-size: 14px; text-anchor: middle;">
                            💡 点击任意节点查看详细信息
                        </text>
                    </svg>
                    
                    <!-- V2.0双模型架构解释 -->
                    <div class="deep-explanation">
                        <h4>🚀 V2.0双模型智能路由架构</h4>
                        <div class="explanation-section">
                            <h5>🤖 DeepSeek-V3：工具调用专家</h5>
                            <p>专门处理需要调用搜索、数据库等工具的任务</p>
                        </div>
                        <div class="explanation-section">
                            <h5>🧠 DeepSeek-R1：推理分析专家</h5>
                            <p>专门处理需要深度思考和逻辑推理的任务</p>
                        </div>
                        <div class="explanation-section">
                            <h5>🚦 智能路由决策</h5>
                            <p>根据查询类型自动选择最合适的模型</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 右侧信息面板 -->
            <div class="info-panel">
                <div class="info-tabs">
                    <button class="info-tab active" onclick="switchInfoTab('concept')">
                        📚 概念原理
                    </button>
                    <button class="info-tab" onclick="switchInfoTab('code')">
                        💻 代码实现
                    </button>
                    <button class="info-tab" onclick="switchInfoTab('runtime')">
                        🚀 运行状态
                    </button>
                </div>

                <!-- 概念原理标签页 -->
                <div id="concept-tab" class="tab-content active">
                    <div id="dynamic-content">
                        <h3>📚 核心概念 <span id="current-state" class="state-indicator dev">开发态</span></h3>
                        <div id="selected-node-info">
                            <p style="color: #666; text-align: center; padding: 20px;">
                                点击左侧流程图中的组件查看详细信息
                            </p>
                        </div>
                    <div class="learning-card" id="right-panel-knowledge-card" style="display: none;">
                        <h4 id="right-knowledge-title">系统对比分析</h4>
                        <div id="right-knowledge-content">
                            <!-- Content will be populated dynamically based on current mode -->
                        </div>
                    </div>
                    
                    </div>
                </div>

                <!-- 代码实现标签页 -->
                <div id="code-tab" class="tab-content">
                    <h3>💻 代码实现 <span id="current-state-code" class="state-indicator dev">开发态</span></h3>
                    <div id="code-display">
                        <p style="color: #666; text-align: center; padding: 20px;">
                            点击左侧流程图中的组件查看对应代码
                        </p>
                    </div>
                </div>

                <!-- 运行状态标签页 -->
                <div id="runtime-tab" class="tab-content">
                    <h3>🚀 运行状态 <span id="current-state-runtime" class="state-indicator dev">开发态</span></h3>
                    <div id="runtime-display">
                        <div id="node-runtime-info">
                            <p style="color: #666; text-align: center; padding: 20px;">
                                点击左侧流程图中的组件查看运行状态
                            </p>
                        </div>
                        <div class="metrics-grid">
                            <div class="metric-item">
                                <div class="metric-value">🟢</div>
                                <div class="metric-label">系统状态</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value">0ms</div>
                                <div class="metric-label">响应时间</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value">0MB</div>
                                <div class="metric-label">内存使用</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value">0%</div>
                                <div class="metric-label">CPU使用</div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <h4 style="color: #2a5298; margin-bottom: 10px;">📝 运行日志</h4>
                            <div id="runtime-log" style="font-family: monospace; font-size: 0.9em; color: #666;">
                                [系统] 等待操作...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- 提示框 -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // 全局状态管理
        let currentMode = 'dev';
        let isProcessing = false;
        let currentStep = 0;
        
        // 节点详细信息数据
        const nodeDetails = {
            'config': {
                title: '📄 环境配置',
                concept: {
                    why: '系统需要知道如何连接各个服务和API',
                    what: '从.env文件读取配置参数',
                    how: '使用python-dotenv库加载环境变量'
                },
                code: `<span class="comment"># backend/config.py</span>
<span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseSettings

<span class="keyword">class</span> <span class="function">Config</span>(BaseSettings):
    <span class="comment"># AI模型配置</span>
    LLM_PROVIDER: str = <span class="string">"deepseek"</span>
    LLM_API_KEY: str
    LLM_BASE_URL: str
    
    <span class="comment"># 双模型配置</span>
    MODEL_REASON: str = <span class="string">"DeepSeek-R1"</span>
    MODEL_TOOLCALL: str = <span class="string">"DeepSeek-V3"</span>
    
    <span class="comment"># 向量数据库配置</span>
    CHROMA_PATH: str = <span class="string">"./chroma_db"</span>
    EMBEDDING_MODEL: str = <span class="string">"all-MiniLM-L6-v2"</span>
    
    <span class="keyword">class</span> Config:
        env_file = <span class="string">".env"</span>`,
                runtime: {
                    status: '已加载',
                    configs: {
                        'API提供商': 'DeepSeek',
                        '向量数据库': 'ChromaDB',
                        '嵌入模型': 'MiniLM-L6'
                    }
                }
            },
            'vectordb': {
                title: '🗄️ 向量数据库',
                concept: {
                    why: '传统数据库无法理解"Python"和"派森"是同一个意思',
                    what: 'ChromaDB是专门存储和检索向量的数据库',
                    how: '通过计算向量之间的余弦相似度找到语义相近的内容'
                },
                code: `<span class="comment"># backend/vector_store.py</span>
<span class="keyword">import</span> chromadb
<span class="keyword">from</span> chromadb.config <span class="keyword">import</span> Settings

<span class="keyword">class</span> <span class="function">VectorStore</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, chroma_path: str):
        <span class="comment"># 初始化ChromaDB客户端</span>
        self.client = chromadb.PersistentClient(
            path=chroma_path,
            settings=Settings(anonymized_telemetry=<span class="keyword">False</span>)
        )
        
    <span class="keyword">def</span> <span class="function">search</span>(self, query: str, k: int = <span class="number">5</span>):
        <span class="comment"># 将查询转换为向量</span>
        query_vector = self.embed(query)
        
        <span class="comment"># 使用余弦相似度搜索</span>
        results = self.collection.query(
            query_embeddings=[query_vector],
            n_results=k
        )
        <span class="keyword">return</span> results`,
                runtime: {
                    status: '运行中',
                    metrics: {
                        '存储文档': 1250,
                        '向量维度': 384,
                        '查询延迟': '45ms'
                    }
                }
            },
            'embedding': {
                title: '🔢 嵌入模型',
                concept: {
                    why: '计算机不能直接理解文字，需要转换成数字',
                    what: 'MiniLM-L6将文本转换为384维向量',
                    how: '通过深度学习模型编码语义信息'
                },
                code: `<span class="comment"># 为什么选择MiniLM-L6？</span>
<span class="comment"># 1. 模型小巧：仅25MB（BERT需要420MB）</span>
<span class="comment"># 2. 速度快：推理速度是BERT的5倍</span>
<span class="comment"># 3. 多语言：支持中英文等多种语言</span>
<span class="comment"># 4. 效果好：在语义相似度任务上表现优秀</span>

<span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer

<span class="comment"># 加载模型</span>
model = SentenceTransformer(<span class="string">'all-MiniLM-L6-v2'</span>)

<span class="comment"># 文本转向量示例</span>
texts = [
    <span class="string">"Python是一种编程语言"</span>,
    <span class="string">"派森是一门编程语言"</span>,
    <span class="string">"Java是一种编程语言"</span>
]

vectors = model.encode(texts)
<span class="comment"># vectors.shape = (3, 384)</span>

<span class="comment"># 计算相似度</span>
<span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity
sim_matrix = cosine_similarity(vectors)
<span class="comment"># Python vs 派森: 0.95 (高相似度)</span>
<span class="comment"># Python vs Java: 0.72 (中等相似度)</span>`,
                runtime: {
                    status: '已加载',
                    metrics: {
                        '模型大小': '25MB',
                        '向量维度': 384,
                        '编码速度': '1000句/秒'
                    }
                }
            },
            'ai-config': {
                title: '🤖 AI模型配置',
                concept: {
                    why: '不同任务需要不同能力的模型',
                    what: 'DeepSeek双模型架构：V3处理工具调用，R1处理推理',
                    how: '根据任务类型智能路由到合适的模型'
                },
                code: `<span class="comment"># backend/ai_generator.py</span>
<span class="keyword">class</span> <span class="function">AIGenerator</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># 双模型配置</span>
        self.model_reason = <span class="string">"DeepSeek-R1"</span>  <span class="comment"># 推理专用</span>
        self.model_toolcall = <span class="string">"DeepSeek-V3"</span>  <span class="comment"># 工具调用专用</span>
        
    <span class="keyword">def</span> <span class="function">route_query</span>(self, query: str, has_tools: bool):
        <span class="comment"># 智能路由决策</span>
        <span class="keyword">if</span> has_tools and self._needs_search(query):
            <span class="comment"># 需要搜索课程内容</span>
            <span class="keyword">return</span> self.model_toolcall  <span class="comment"># 使用V3</span>
        <span class="keyword">else</span>:
            <span class="comment"># 一般知识问答</span>
            <span class="keyword">return</span> self.model_reason  <span class="comment"># 使用R1</span>
            
    <span class="keyword">def</span> <span class="function">_needs_search</span>(self, query: str):
        <span class="comment"># 判断是否需要搜索</span>
        keywords = [<span class="string">"课程"</span>, <span class="string">"章节"</span>, <span class="string">"内容"</span>, <span class="string">"学习"</span>]
        <span class="keyword">return</span> any(kw <span class="keyword">in</span> query <span class="keyword">for</span> kw <span class="keyword">in</span> keywords)`,
                runtime: {
                    status: '已配置',
                    metrics: {
                        'R1模型': '推理任务',
                        'V3模型': '工具调用',
                        '降级方案': 'Claude API'
                    }
                }
            },
            'router': {
                title: '🚦 智能路由器',
                concept: {
                    why: '不同查询需要不同的处理策略',
                    what: '分析查询意图，选择最合适的处理路径',
                    how: '基于规则和模式匹配进行决策'
                },
                code: `<span class="comment"># 路由决策树</span>
<span class="keyword">def</span> <span class="function">intelligent_routing</span>(query: str, context: dict):
    <span class="comment">"""
    智能路由决策流程
    
    决策因素：
    1. 查询类型（课程内容 vs 通用知识）
    2. 是否需要工具调用
    3. 上下文信息
    4. 系统负载
    """</span>
    
    <span class="comment"># Step 1: 分析查询类型</span>
    query_type = analyze_query(query)
    
    <span class="comment"># Step 2: 决策路由</span>
    <span class="keyword">if</span> query_type == <span class="string">"course_content"</span>:
        <span class="comment"># 需要搜索课程材料</span>
        model = <span class="string">"DeepSeek-V3"</span>
        tools = [<span class="string">"search_course"</span>]
        path = <span class="string">"tool_calling_path"</span>
    <span class="keyword">elif</span> query_type == <span class="string">"general_knowledge"</span>:
        <span class="comment"># 通用知识问答</span>
        model = <span class="string">"DeepSeek-R1"</span>
        tools = []
        path = <span class="string">"direct_reasoning_path"</span>
    <span class="keyword">else</span>:
        <span class="comment"># 混合型查询</span>
        model = <span class="string">"DeepSeek-V3"</span>
        tools = [<span class="string">"search_course"</span>]
        path = <span class="string">"hybrid_path"</span>
        
    <span class="keyword">return</span> {
        <span class="string">"model"</span>: model,
        <span class="string">"tools"</span>: tools,
        <span class="string">"path"</span>: path
    }`,
                runtime: {
                    status: '就绪',
                    metrics: {
                        '路由策略': '基于任务',
                        '模型池': 2,
                        '降级支持': '是'
                    }
                }
            }
        };

        // 初始化
        document.addEventListener('DOMContentLoaded', () => {
            initializeVectorVisualization();
            addTooltips();
            updateMetrics();
            
            // 初始化知识卡片（默认开发态）
            updateLeftPanelKnowledgeCard('dev');
            updateRightPanelKnowledgeCard('dev');
        });

        // 切换模式
        function switchMode(mode, event) {
            if (isProcessing) return;
            
            currentMode = mode;
            
            // 更新按钮状态
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 处理事件对象
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active');
            } else {
                // 没有事件时，根据mode找到对应的按钮
                const modeMap = {
                    'dev': 0,
                    'manage': 1,
                    'runtime': 2
                };
                const btns = document.querySelectorAll('.mode-btn');
                if (btns[modeMap[mode]]) {
                    btns[modeMap[mode]].classList.add('active');
                }
            }
            
            // 更新流程图
            document.querySelectorAll('.flow-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(mode + '-flow').style.display = 'block';
            
            // 更新标题
            const titles = {
                'dev': '🛠️ 开发态 - 系统初始化',
                'manage': '📋 管理态 - 文档处理',
                'runtime': '🚀 运行态 - 查询处理'
            };
            document.getElementById('stage-title').textContent = titles[mode];
            
            // 更新右侧面板状态指示器
            updateStateIndicators(mode);
            
            // 更新左侧面板知识卡片
            updateLeftPanelKnowledgeCard(mode);
            
            // 更新右侧面板知识卡片
            updateRightPanelKnowledgeCard(mode);
            
            // 显示右侧知识卡片
            const rightKnowledgeCard = document.getElementById('right-panel-knowledge-card');
            if (rightKnowledgeCard) {
                rightKnowledgeCard.style.display = 'block';
            }
            
            // 重置节点状态和选择
            resetNodes();
            clearNodeSelection();
            
            // 添加日志
            addLog(`切换到${titles[mode]}`);
        }
        
        // 更新状态指示器
        function updateStateIndicators(mode) {
            const stateNames = {
                'dev': '开发态',
                'manage': '管理态',
                'runtime': '运行态'
            };
            
            const indicators = [
                'current-state',
                'current-state-code', 
                'current-state-runtime'
            ];
            
            indicators.forEach(id => {
                const indicator = document.getElementById(id);
                if (indicator) {
                    indicator.textContent = stateNames[mode];
                    indicator.className = `state-indicator ${mode}`;
                }
            });
        }
        
        // 更新左侧面板知识卡片
        function updateLeftPanelKnowledgeCard(mode) {
            const learningCard = document.getElementById('context-learning-card');
            const cardTitle = document.getElementById('learning-card-title');
            const cardContent = document.getElementById('learning-card-content');
            
            if (!learningCard || !cardTitle || !cardContent) return;
            
            const cardConfigs = {
                'dev': {
                    title: '🛠️ 开发态配置要点',
                    content: `
                        <div class="concept-box">
                            <strong>环境配置：</strong>
                            确保API密钥正确配置，模型服务可用
                        </div>
                        <div class="concept-box">
                            <strong>依赖检查：</strong>
                            验证ChromaDB、向量模型等组件状态
                        </div>
                        <div class="analogy-box">
                            <h5>💡 开发提示</h5>
                            <div class="analogy-item">
                                <span class="icon">🔧</span>
                                <span>先配置环境，再启动服务</span>
                            </div>
                            <div class="analogy-item">
                                <span class="icon">📝</span>
                                <span>检查日志确认组件正常</span>
                            </div>
                        </div>
                    `
                },
                'manage': {
                    title: '📋 管理态处理技巧',
                    content: `
                        <div class="concept-box">
                            <strong>文档准备：</strong>
                            支持MD、PDF、TXT等格式，建议预处理
                        </div>
                        <div class="concept-box">
                            <strong>分块策略：</strong>
                            500字符/块，100字符重叠保证连贯性
                        </div>
                        <div class="analogy-box">
                            <h5>💡 处理建议</h5>
                            <div class="analogy-item">
                                <span class="icon">📄</span>
                                <span>文档质量影响搜索效果</span>
                            </div>
                            <div class="analogy-item">
                                <span class="icon">✂️</span>
                                <span>合理分块提高匹配精度</span>
                            </div>
                        </div>
                    `
                },
                'runtime': {
                    title: '🚀 运行态查询优化',
                    content: `
                        <div class="concept-box">
                            <strong>查询技巧：</strong>
                            使用具体关键词，避免过于宽泛的问题
                        </div>
                        <div class="concept-box">
                            <strong>双模型优势：</strong>
                            V3处理工具调用，R1专攻推理分析
                        </div>
                        <div class="analogy-box">
                            <h5>💡 查询建议</h5>
                            <div class="analogy-item">
                                <span class="icon">🎯</span>
                                <span>明确问题得到精准答案</span>
                            </div>
                            <div class="analogy-item">
                                <span class="icon">🔄</span>
                                <span>智能路由自动选择最佳模型</span>
                            </div>
                        </div>
                    `
                }
            };
            
            const config = cardConfigs[mode];
            if (config) {
                cardTitle.textContent = config.title;
                cardContent.innerHTML = config.content;
            }
        }
        
        // 更新右侧面板知识卡片
        function updateRightPanelKnowledgeCard(mode) {
            const knowledgeCard = document.getElementById('right-panel-knowledge-card');
            const cardTitle = document.getElementById('right-knowledge-title');
            const cardContent = document.getElementById('right-knowledge-content');
            
            if (!knowledgeCard || !cardTitle || !cardContent) return;
            
            const cardConfigs = {
                'dev': {
                    title: '系统架构对比',
                    content: `
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>组件</th>
                                    <th>传统方案</th>
                                    <th>RAG方案</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>存储</td>
                                    <td>关系数据库</td>
                                    <td>向量数据库</td>
                                </tr>
                                <tr>
                                    <td>搜索</td>
                                    <td>关键词匹配</td>
                                    <td>语义相似度</td>
                                </tr>
                                <tr>
                                    <td>理解</td>
                                    <td>字面匹配</td>
                                    <td>上下文理解</td>
                                </tr>
                                <tr>
                                    <td>扩展性</td>
                                    <td>需修改代码</td>
                                    <td>动态学习</td>
                                </tr>
                            </tbody>
                        </table>
                    `
                },
                'manage': {
                    title: '文档处理流程',
                    content: `
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>步骤</th>
                                    <th>输入</th>
                                    <th>输出</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>文档输入</td>
                                    <td>原始文档</td>
                                    <td>文件流</td>
                                </tr>
                                <tr>
                                    <td>格式解析</td>
                                    <td>文件流</td>
                                    <td>纯文本</td>
                                </tr>
                                <tr>
                                    <td>文本分块</td>
                                    <td>长文本</td>
                                    <td>文本块数组</td>
                                </tr>
                                <tr>
                                    <td>向量化</td>
                                    <td>文本块</td>
                                    <td>384维向量</td>
                                </tr>
                                <tr>
                                    <td>存储</td>
                                    <td>向量+元数据</td>
                                    <td>可搜索索引</td>
                                </tr>
                            </tbody>
                        </table>
                    `
                },
                'runtime': {
                    title: '双模型处理对比',
                    content: `
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>特性</th>
                                    <th>DeepSeek-V3</th>
                                    <th>DeepSeek-R1</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>专长</td>
                                    <td>工具调用</td>
                                    <td>深度推理</td>
                                </tr>
                                <tr>
                                    <td>使用场景</td>
                                    <td>需要搜索时</td>
                                    <td>分析总结时</td>
                                </tr>
                                <tr>
                                    <td>响应速度</td>
                                    <td>快速</td>
                                    <td>深度思考</td>
                                </tr>
                                <tr>
                                    <td>输出质量</td>
                                    <td>精准工具执行</td>
                                    <td>逻辑推理</td>
                                </tr>
                            </tbody>
                        </table>
                    `
                }
            };
            
            const config = cardConfigs[mode];
            if (config) {
                cardTitle.textContent = config.title;
                cardContent.innerHTML = config.content;
            }
        }

        // 切换信息面板标签
        function switchInfoTab(tab) {
            // 阻止事件冒泡
            if (event) {
                event.stopPropagation();
            }
            
            // 更新标签状态
            document.querySelectorAll('.info-tab').forEach(t => {
                t.classList.remove('active');
            });
            
            // 找到被点击的标签按钮并激活
            const clickedTab = document.querySelector(`[onclick="switchInfoTab('${tab}')"]`);
            if (clickedTab) {
                clickedTab.classList.add('active');
            }
            
            // 更新内容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tab + '-tab').classList.add('active');
        }

        // 当前选中的节点
        let currentSelectedNode = null;
        
        // 显示节点详情 - 更新右侧面板
        function showNodeDetail(nodeId, customDetail = null) {
            const detail = customDetail || nodeDetails[nodeId];
            if (!detail) return;
            
            // 移除之前选中节点的高亮
            if (currentSelectedNode) {
                const prevNode = document.getElementById(currentSelectedNode + '-node');
                if (prevNode) {
                    prevNode.classList.remove('node-selected');
                }
            }
            
            // 高亮当前选中的节点
            const currentNode = document.getElementById(nodeId + '-node');
            if (currentNode) {
                currentNode.classList.add('node-selected');
            }
            currentSelectedNode = nodeId;
            
            // 更新右侧面板内容
            updateRightPanel(detail);
        }
        
        // 更新右侧面板内容
        function updateRightPanel(detail) {
            // 更新概念原理标签页
            const conceptInfo = document.getElementById('selected-node-info');
            if (conceptInfo) {
                conceptInfo.innerHTML = `
                    <div class="panel-section">
                        <h4>${detail.title}</h4>
                        <div class="concept-box">
                            <strong>Why（为什么）：</strong>
                            ${detail.concept.why}
                        </div>
                        <div class="concept-box">
                            <strong>What（是什么）：</strong>
                            ${detail.concept.what}
                        </div>
                        <div class="concept-box">
                            <strong>How（怎么做）：</strong>
                            ${detail.concept.how}
                        </div>
                    </div>
                `;
            }
            
            // 隐藏右侧知识卡片，突出显示节点特定内容
            const rightKnowledgeCard = document.getElementById('right-panel-knowledge-card');
            if (rightKnowledgeCard) {
                rightKnowledgeCard.style.display = 'none';
            }
            
            // 更新代码实现标签页
            const codeDisplay = document.getElementById('code-display');
            if (codeDisplay) {
                codeDisplay.innerHTML = `
                    <div class="panel-section">
                        <h4>${detail.title} - 代码实现</h4>
                        <div class="code-block">${detail.code}</div>
                    </div>
                `;
            }
            
            // 更新运行状态标签页
            const runtimeInfo = document.getElementById('node-runtime-info');
            if (runtimeInfo) {
                runtimeInfo.innerHTML = `
                    <div class="panel-section">
                        <h4>${detail.title} - 运行状态</h4>
                        <div class="metrics-grid">
                            ${Object.entries(detail.runtime.metrics || {}).map(([key, value]) => `
                                <div class="metric-item">
                                    <div class="metric-value">${value}</div>
                                    <div class="metric-label">${key}</div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                            <strong>状态：</strong> ${detail.runtime.status}
                        </div>
                    </div>
                `;
            }
        }
        
        // 清除节点选择
        function clearNodeSelection() {
            if (currentSelectedNode) {
                const node = document.getElementById(currentSelectedNode + '-node');
                if (node) {
                    node.classList.remove('node-selected');
                }
            }
            currentSelectedNode = null;
            
            // 重置右侧面板内容
            resetRightPanel();
        }
        
        // 重置右侧面板内容
        function resetRightPanel() {
            const conceptInfo = document.getElementById('selected-node-info');
            if (conceptInfo) {
                conceptInfo.innerHTML = `
                    <p style="color: #666; text-align: center; padding: 20px;">
                        点击左侧流程图中的组件查看详细信息
                    </p>
                `;
            }
            
            const codeDisplay = document.getElementById('code-display');
            if (codeDisplay) {
                codeDisplay.innerHTML = `
                    <p style="color: #666; text-align: center; padding: 20px;">
                        点击左侧流程图中的组件查看对应代码
                    </p>
                `;
            }
            
            const runtimeInfo = document.getElementById('node-runtime-info');
            if (runtimeInfo) {
                runtimeInfo.innerHTML = `
                    <p style="color: #666; text-align: center; padding: 20px;">
                        点击左侧流程图中的组件查看运行状态
                    </p>
                `;
            }
            
            // 显示右侧知识卡片
            const rightKnowledgeCard = document.getElementById('right-panel-knowledge-card');
            if (rightKnowledgeCard) {
                rightKnowledgeCard.style.display = 'block';
            }
        }

        // 初始化向量空间可视化
        function initializeVectorVisualization() {
            const canvas = document.getElementById('vector-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 清空画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制网格背景
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, height);
                ctx.stroke();
            }
            for (let i = 0; i <= height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(width, i);
                ctx.stroke();
            }
            
            // 绘制坐标轴
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2, 0);
            ctx.lineTo(width/2, height);
            ctx.moveTo(0, height/2);
            ctx.lineTo(width, height/2);
            ctx.stroke();
            
            // 坐标轴标签
            ctx.fillStyle = '#007bff';
            ctx.font = '14px sans-serif';
            ctx.fillText('维度1', width - 50, height/2 - 10);
            ctx.save();
            ctx.translate(20, 50);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('维度2', 0, 0);
            ctx.restore();
            
            // 模拟文档向量（蓝点）- 调整到新画布尺寸
            const docVectors = [
                {x: 150, y: 120, label: 'Python基础教程', similarity: 0.92},
                {x: 180, y: 140, label: 'Python编程入门', similarity: 0.89},
                {x: 350, y: 200, label: 'Java开发指南', similarity: 0.45},
                {x: 420, y: 280, label: '数据库设计', similarity: 0.35},
                {x: 200, y: 160, label: 'Python函数详解', similarity: 0.87},
                {x: 480, y: 120, label: 'Web开发基础', similarity: 0.52},
                {x: 120, y: 300, label: '算法与数据结构', similarity: 0.68},
                {x: 380, y: 100, label: 'JavaScript入门', similarity: 0.41}
            ];
            
            // 绘制文档向量
            docVectors.forEach(vec => {
                // 根据相似度设置颜色深度
                const alpha = Math.max(0.3, vec.similarity);
                ctx.fillStyle = `rgba(102, 126, 234, ${alpha})`;
                ctx.beginPath();
                ctx.arc(vec.x, vec.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // 边框
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 标签
                ctx.fillStyle = '#444';
                ctx.font = '12px sans-serif';
                const labelX = vec.x + 12;
                const labelY = vec.y + 4;
                ctx.fillText(vec.label, labelX, labelY);
                
                // 相似度标签
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.fillText(`${(vec.similarity * 100).toFixed(0)}%`, labelX, labelY + 12);
            });
            
            // 查询向量（红点）
            const queryVector = {x: 170, y: 130, label: '查询：Python编程'};
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(queryVector.x, queryVector.y, 12, 0, 2 * Math.PI);
            ctx.fill();
            
            // 查询向量边框
            ctx.strokeStyle = '#ff4757';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // 查询标签
            ctx.fillStyle = '#ff4757';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(queryVector.label, queryVector.x + 15, queryVector.y - 10);
            
            // 绘制相似度连线（绿线）
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            
            // 只连接高相似度的文档（相似度 > 0.8）
            const highSimilarityDocs = docVectors.filter(vec => vec.similarity > 0.8);
            highSimilarityDocs.forEach(vec => {
                const alpha = vec.similarity;
                ctx.strokeStyle = `rgba(40, 167, 69, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(queryVector.x, queryVector.y);
                ctx.lineTo(vec.x, vec.y);
                ctx.stroke();
                
                // 在连线中点显示相似度
                const midX = (queryVector.x + vec.x) / 2;
                const midY = (queryVector.y + vec.y) / 2;
                ctx.fillStyle = '#28a745';
                ctx.font = 'bold 11px sans-serif';
                ctx.fillText(`${(vec.similarity * 100).toFixed(0)}%`, midX, midY - 5);
            });
            
            // 重置线条样式
            ctx.setLineDash([]);
            
            // 添加图例
            const legendX = 20;
            const legendY = height - 80;
            
            // 查询向量图例
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(legendX, legendY, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.fillText('查询向量', legendX + 15, legendY + 4);
            
            // 文档向量图例
            ctx.fillStyle = '#667eea';
            ctx.beginPath();
            ctx.arc(legendX, legendY + 25, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText('文档向量', legendX + 15, legendY + 29);
            
            // 相似度连线图例
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(legendX - 5, legendY + 50);
            ctx.lineTo(legendX + 30, legendY + 50);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillText('高相似度连接', legendX + 35, legendY + 54);
        }

        // 开始演示
        function startDemo() {
            if (isProcessing) return;
            
            isProcessing = true;
            currentStep = 0;
            
            document.getElementById('status-text').textContent = '演示进行中...';
            
            // 根据当前模式运行不同的演示
            if (currentMode === 'dev') {
                runDevDemo();
            } else if (currentMode === 'manage') {
                runManageDemo();
            } else if (currentMode === 'runtime') {
                runRuntimeDemo();
            }
        }

        // 开发态演示
        function runDevDemo() {
            const steps = [
                {node: 'config-node', delay: 500},
                {node: 'vectordb-node', delay: 800},
                {node: 'embedding-node', delay: 600},
                {node: 'ai-config-node', delay: 700},
                {node: 'router-node', delay: 900}
            ];
            
            runSteps(steps);
        }

        // 管理态演示
        function runManageDemo() {
            const steps = [
                {node: 'doc-input-node', delay: 500},
                {node: 'doc-parse-node', delay: 800},
                {node: 'chunk-node', delay: 1000},
                {node: 'vectorize-node', delay: 1200},
                {node: 'store-node', delay: 600}
            ];
            
            runSteps(steps);
        }

        // 运行态演示
        function runRuntimeDemo() {
            const steps = [
                {node: 'user-input-node', delay: 300, log: '接收用户查询'},
                {node: 'api-receive-node', delay: 400, log: 'FastAPI接收请求'},
                {node: 'session-mgmt-node', delay: 500, log: '获取会话历史'},
                {node: 'tool-prep-node', delay: 600, log: '准备工具定义'},
                {node: 'router-decision-node', delay: 800, log: '🚦 智能路由决策：需要工具调用'},
                {node: 'model-v3-node', delay: 700, log: '选择DeepSeek-V3处理工具调用'},
                {node: 'tool-call-node', delay: 900, log: '执行search_course工具'},
                {node: 'vector-search-node', delay: 1000, log: '向量数据库搜索完成'},
                {node: 'model-switch-node', delay: 800, log: '🔄 模型切换：V3 → R1'},
                {node: 'result-integrate-node', delay: 1200, log: 'R1模型整合搜索结果'},
                {node: 'final-response-node', delay: 600, log: '✅ 生成最终答案'}
            ];
            
            addLog('开始V2.0双模型处理流程');
            runSteps(steps);
        }
        
        // 管理态节点详情数据
        const manageNodeDetails = {
            'doc-input': {
                title: '📥 文档输入',
                concept: {
                    why: '系统需要处理各种格式的课程材料',
                    what: '支持Markdown、PDF、TXT等文档格式的上传和输入',
                    how: '通过Web界面上传或API接口接收文档数据'
                },
                code: `<span class="comment"># backend/document_processor.py</span>
<span class="keyword">class</span> <span class="function">DocumentProcessor</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.supported_formats = [<span class="string">".md"</span>, <span class="string">".pdf"</span>, <span class="string">".txt"</span>, <span class="string">".docx"</span>]
        
    <span class="keyword">def</span> <span class="function">process_upload</span>(self, file_path: str):
        <span class="comment"># 检查文件格式</span>
        file_ext = Path(file_path).suffix.lower()
        <span class="keyword">if</span> file_ext not <span class="keyword">in</span> self.supported_formats:
            <span class="keyword">raise</span> ValueError(f<span class="string">"不支持的文件格式: {file_ext}"</span>)
            
        <span class="comment"># 读取文件内容</span>
        <span class="keyword">if</span> file_ext == <span class="string">".pdf"</span>:
            content = self._extract_pdf(file_path)
        <span class="keyword">elif</span> file_ext == <span class="string">".md"</span>:
            content = self._extract_markdown(file_path)
        <span class="keyword">else</span>:
            content = self._extract_text(file_path)
            
        <span class="keyword">return</span> {
            <span class="string">"content"</span>: content,
            <span class="string">"metadata"</span>: self._extract_metadata(file_path)
        }`,
                runtime: {
                    status: '待上传',
                    metrics: {
                        '支持格式': '4种',
                        '最大文件': '10MB',
                        '处理速度': '1MB/s'
                    }
                }
            },
            'doc-parse': {
                title: '🔍 文档解析',
                concept: {
                    why: '不同文档格式需要不同的解析策略',
                    what: '提取文档中的文本内容和结构信息',
                    how: '使用专门的解析库处理不同文件格式'
                },
                code: `<span class="comment"># 不同格式的解析策略</span>
<span class="keyword">def</span> <span class="function">_extract_pdf</span>(self, file_path: str):
    <span class="keyword">import</span> PyPDF2
    <span class="keyword">with</span> open(file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> file:
        reader = PyPDF2.PdfReader(file)
        content = <span class="string">""</span>
        <span class="keyword">for</span> page <span class="keyword">in</span> reader.pages:
            content += page.extract_text() + <span class="string">"\\n"</span>
    <span class="keyword">return</span> content

<span class="keyword">def</span> <span class="function">_extract_markdown</span>(self, file_path: str):
    <span class="keyword">import</span> markdown
    <span class="keyword">with</span> open(file_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:
        md_content = file.read()
        <span class="comment"># 保留原始文本，不转换为HTML</span>
        <span class="keyword">return</span> md_content

<span class="keyword">def</span> <span class="function">_extract_text</span>(self, file_path: str):
    <span class="keyword">with</span> open(file_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:
        <span class="keyword">return</span> file.read()`,
                runtime: {
                    status: '就绪',
                    metrics: {
                        'PDF解析': '支持',
                        'MD解析': '支持',
                        '编码支持': 'UTF-8'
                    }
                }
            },
            'chunk': {
                title: '✂️ 文本分块',
                concept: {
                    why: '模型输入限制和提高搜索精度',
                    what: '将长文档分割成小块，保持上下文连贯性',
                    how: '按字符数分块，设置重叠区间'
                },
                code: `<span class="comment"># 文本分块算法</span>
<span class="keyword">class</span> <span class="function">TextChunker</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, chunk_size=<span class="number">500</span>, overlap=<span class="number">100</span>):
        self.chunk_size = chunk_size
        self.overlap = overlap
        
    <span class="keyword">def</span> <span class="function">chunk_text</span>(self, text: str):
        chunks = []
        start = <span class="number">0</span>
        
        <span class="keyword">while</span> start < len(text):
            <span class="comment"># 计算块的结束位置</span>
            end = start + self.chunk_size
            chunk = text[start:end]
            
            <span class="comment"># 在句子边界切分（优化）</span>
            <span class="keyword">if</span> end < len(text):
                boundary = self._find_sentence_boundary(text, end)
                <span class="keyword">if</span> boundary > start:
                    chunk = text[start:boundary]
                    
            chunks.append(chunk.strip())
            start = end - self.overlap
            
        <span class="keyword">return</span> chunks`,
                runtime: {
                    status: '就绪',
                    metrics: {
                        '块大小': '500字符',
                        '重叠大小': '100字符',
                        '切分策略': '智能边界'
                    }
                }
            },
            'vectorize': {
                title: '🔢 向量化',
                concept: {
                    why: '计算机需要数字化表示才能理解语义',
                    what: '使用MiniLM-L6模型将文本转换为384维向量',
                    how: '通过训练好的神经网络模型提取语义特征'
                },
                code: `<span class="comment"># 向量化处理器</span>
<span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">class</span> <span class="function">VectorEmbedder</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, model_name=<span class="string">"all-MiniLM-L6-v2"</span>):
        self.model = SentenceTransformer(model_name)
        
    <span class="keyword">def</span> <span class="function">embed_chunks</span>(self, chunks: list):
        <span class="comment"># 批量处理提高效率</span>
        embeddings = self.model.encode(chunks, 
                                     batch_size=<span class="number">32</span>,
                                     show_progress_bar=<span class="keyword">True</span>)
        
        <span class="comment"># 向量正规化（可选）</span>
        normalized_embeddings = embeddings / np.linalg.norm(
            embeddings, axis=<span class="number">1</span>, keepdims=<span class="keyword">True</span>
        )
        
        <span class="keyword">return</span> normalized_embeddings`,
                runtime: {
                    status: '就绪',
                    metrics: {
                        '模型大小': '25MB',
                        '向量维度': '384',
                        '处理速度': '1000块/秒'
                    }
                }
            },
            'store': {
                title: '💾 数据存储',
                concept: {
                    why: '需要持久化存储向量数据供后续搜索',
                    what: '将文本块和对应向量存储到ChromaDB',
                    how: '使用向量数据库的专用API进行存储和索引'
                },
                code: `<span class="comment"># ChromaDB存储管理</span>
<span class="keyword">class</span> <span class="function">ChromaStorage</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, collection_name=<span class="string">"course_materials"</span>):
        self.client = chromadb.PersistentClient(path=<span class="string">"./chroma_db"</span>)
        self.collection = self.client.get_or_create_collection(
            name=collection_name,
            metadata={<span class="string">"hnsw:space"</span>: <span class="string">"cosine"</span>}  <span class="comment"># 余弦相似度</span>
        )
        
    <span class="keyword">def</span> <span class="function">store_chunks</span>(self, chunks: list, embeddings: list, metadata: list):
        <span class="comment"># 批量存储</span>
        ids = [f<span class="string">"chunk_{i}"</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(chunks))]
        
        self.collection.add(
            embeddings=embeddings.tolist(),
            documents=chunks,
            metadatas=metadata,
            ids=ids
        )
        
        <span class="keyword">return</span> len(chunks)`,
                runtime: {
                    status: '运行中',
                    metrics: {
                        '存储块数': '0',
                        '数据库大小': '0MB',
                        '搜索延迟': '<50ms'
                    }
                }
            }
        };
        
        // 运行态节点详情数据
        const runtimeNodeDetails = {
            'user-input': {
                title: '🔍 用户输入',
                concept: {
                    why: '用户需要获取课程相关信息或解答疑问',
                    what: '接收用户的自然语言查询请求',
                    how: '通过Web界面收集用户输入的问题文本'
                },
                code: `<span class="comment"># frontend/query_interface.py</span>
<span class="keyword">def</span> <span class="function">handle_user_input</span>(query: str):
    <span class="comment"># 输入验证</span>
    <span class="keyword">if</span> not query or len(query.strip()) < <span class="number">3</span>:
        <span class="keyword">return</span> {<span class="string">"error"</span>: <span class="string">"查询内容过短"</span>}
    
    <span class="comment"># 清理和预处理</span>
    clean_query = query.strip().replace(<span class="string">"\\n"</span>, <span class="string">" "</span>)
    
    <span class="comment"># 记录用户查询</span>
    log_user_query(clean_query)
    
    <span class="keyword">return</span> {
        <span class="string">"query"</span>: clean_query,
        <span class="string">"timestamp"</span>: datetime.now(),
        <span class="string">"session_id"</span>: get_session_id()
    }`,
                runtime: {
                    status: '等待输入',
                    metrics: {
                        '查询长度': '0字符',
                        '处理时间': '<1ms',
                        '验证状态': '待验证'
                    }
                }
            },
            'api-receive': {
                title: '🌐 API接收',
                concept: {
                    why: 'FastAPI作为后端服务接收前端请求',
                    what: '处理HTTP POST请求，解析查询参数',
                    how: '通过RESTful API端点接收并验证请求数据'
                },
                code: `<span class="comment"># backend/app.py</span>
@app.post(<span class="string">"/query"</span>)
<span class="keyword">async def</span> <span class="function">query_endpoint</span>(request: QueryRequest):
    <span class="comment"># 接收查询请求</span>
    query_data = {
        <span class="string">"query"</span>: request.query,
        <span class="string">"session_id"</span>: request.session_id,
        <span class="string">"timestamp"</span>: datetime.now()
    }
    
    <span class="comment"># 记录请求日志</span>
    logger.info(f<span class="string">"收到查询: {request.query[:50]}..."</span>)
    
    <span class="comment"># 调用RAG处理器</span>
    response = <span class="keyword">await</span> rag_processor.process(query_data)
    
    <span class="keyword">return</span> response`,
                runtime: {
                    status: '监听中',
                    metrics: {
                        '端口': '8000',
                        '请求数': '0',
                        '平均响应': '0ms'
                    }
                }
            }
            },
            'session-mgmt': {
                title: '📋 会话管理',
                concept: {
                    why: '维持用户对话上下文，提供连贯的交互体验',
                    what: '管理用户会话状态，存储历史对话记录',
                    how: '使用session ID跟踪用户状态和对话历史'
                },
                code: `<span class="comment"># backend/session_manager.py</span>
<span class="keyword">class</span> <span class="function">SessionManager</span>:
    <span class="keyword">def __init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.sessions = {}
        <span class="keyword">self</span>.max_history = <span class="number">10</span>
    
    <span class="keyword">def</span> <span class="function">get_session</span>(<span class="keyword">self</span>, session_id: str):
        <span class="keyword">if</span> session_id not <span class="keyword">in</span> <span class="keyword">self</span>.sessions:
            <span class="keyword">self</span>.sessions[session_id] = {
                <span class="string">"history"</span>: [],
                <span class="string">"context"</span>: {},
                <span class="string">"created_at"</span>: datetime.now()
            }
        <span class="keyword">return</span> <span class="keyword">self</span>.sessions[session_id]`,
                runtime: {
                    status: '活跃会话',
                    metrics: {
                        '会话数': '1',
                        '历史记录': '0条',
                        '内存使用': '1.2MB'
                    }
                }
            },
            'tool-prep': {
                title: '🔧 工具准备',
                concept: {
                    why: '为AI模型准备标准化的工具和函数调用格式',
                    what: '转换查询为模型可理解的工具调用格式',
                    how: '构建function schema和参数，准备tool calling'
                },
                code: `<span class="comment"># backend/tool_processor.py</span>
<span class="keyword">def</span> <span class="function">prepare_tools</span>(query: str, session_context: dict):
    tools = [
        {
            <span class="string">"name"</span>: <span class="string">"search_documents"</span>,
            <span class="string">"description"</span>: <span class="string">"搜索相关课程文档"</span>,
            <span class="string">"parameters"</span>: {
                <span class="string">"type"</span>: <span class="string">"object"</span>,
                <span class="string">"properties"</span>: {
                    <span class="string">"query"</span>: {<span class="string">"type"</span>: <span class="string">"string"</span>}
                }
            }
        }
    ]
    
    <span class="keyword">return</span> {
        <span class="string">"tools"</span>: tools,
        <span class="string">"query"</span>: query,
        <span class="string">"context"</span>: session_context
    }`,
                runtime: {
                    status: '工具就绪',
                    metrics: {
                        '可用工具': '3个',
                        '准备时间': '2ms',
                        '格式检查': '通过'
                    }
                }
            },
            'router-decision': {
                title: '🚦 路由决策',
                concept: {
                    why: '智能判断查询类型，选择最优处理路径',
                    what: '分析查询内容，决定使用直接回答还是RAG检索',
                    how: '基于查询特征和规则引擎进行路由决策'
                },
                code: `<span class="comment"># backend/router.py</span>
<span class="keyword">class</span> <span class="function">QueryRouter</span>:
    <span class="keyword">def</span> <span class="function">route</span>(<span class="keyword">self</span>, query: str) -> str:
        <span class="comment"># 简单问候处理</span>
        <span class="keyword">if</span> <span class="keyword">self</span>._is_greeting(query):
            <span class="keyword">return</span> <span class="string">"direct"</span>
        
        <span class="comment"># 知识查询检测</span>
        <span class="keyword">if</span> <span class="keyword">self</span>._needs_knowledge(query):
            <span class="keyword">return</span> <span class="string">"rag"</span>
        
        <span class="comment"># 默认使用RAG</span>
        <span class="keyword">return</span> <span class="string">"rag"</span>
    
    <span class="keyword">def</span> <span class="function">_needs_knowledge</span>(<span class="keyword">self</span>, query: str) -> bool:
        knowledge_keywords = [<span class="string">"什么是"</span>, <span class="string">"如何"</span>, <span class="string">"解释"</span>]
        <span class="keyword">return</span> any(kw <span class="keyword">in</span> query <span class="keyword">for</span> kw <span class="keyword">in</span> knowledge_keywords)`,
                runtime: {
                    status: '决策完成',
                    metrics: {
                        '路由结果': 'RAG路径',
                        '决策时间': '5ms',
                        '置信度': '85%'
                    }
                }
            },
            'model-v3': {
                title: '🤖 模型V3',
                concept: {
                    why: 'Claude 3作为主要推理引擎处理复杂查询',
                    what: '使用Claude 3 Sonnet进行高质量文本生成',
                    how: '发送格式化请求到Anthropic API获取响应'
                },
                code: `<span class="comment"># backend/claude_client.py</span>
<span class="keyword">class</span> <span class="function">ClaudeClient</span>:
    <span class="keyword">def __init__</span>(<span class="keyword">self</span>, api_key: str):
        <span class="keyword">self</span>.client = anthropic.Anthropic(api_key=api_key)
    
    <span class="keyword">async def</span> <span class="function">generate</span>(<span class="keyword">self</span>, messages: list, tools=None):
        response = <span class="keyword">await</span> <span class="keyword">self</span>.client.messages.create(
            model=<span class="string">"claude-3-sonnet-20240229"</span>,
            max_tokens=<span class="number">2048</span>,
            messages=messages,
            tools=tools <span class="keyword">if</span> tools <span class="keyword">else</span> None
        )
        
        <span class="keyword">return</span> response`,
                runtime: {
                    status: '推理中',
                    metrics: {
                        '模型版本': 'Claude-3-Sonnet',
                        'Token使用': '156/2048',
                        '响应时间': '1.2s'
                    }
                }
            },
            'tool-call': {
                title: '🛠️ 工具调用',
                concept: {
                    why: '执行模型决定调用的具体工具函数',
                    what: '根据模型输出执行相应的工具调用',
                    how: '解析tool call参数，执行对应函数并返回结果'
                },
                code: `<span class="comment"># backend/tool_executor.py</span>
<span class="keyword">class</span> <span class="function">ToolExecutor</span>:
    <span class="keyword">def __init__</span>(<span class="keyword">self</span>, vector_store):
        <span class="keyword">self</span>.vector_store = vector_store
    
    <span class="keyword">async def</span> <span class="function">execute</span>(<span class="keyword">self</span>, tool_call):
        <span class="keyword">if</span> tool_call.name == <span class="string">"search_documents"</span>:
            query = tool_call.parameters[<span class="string">"query"</span>]
            results = <span class="keyword">await</span> <span class="keyword">self</span>.vector_store.search(
                query, limit=<span class="number">5</span>
            )
            <span class="keyword">return</span> {
                <span class="string">"results"</span>: results,
                <span class="string">"count"</span>: len(results)
            }`,
                runtime: {
                    status: '执行中',
                    metrics: {
                        '调用工具': 'search_documents',
                        '执行时间': '45ms',
                        '结果数量': '5个'
                    }
                }
            },
            'vector-search': {
                title: '🔍 向量搜索',
                concept: {
                    why: '在高维向量空间中找到与查询最相似的文档',
                    what: '使用ChromaDB进行语义相似度搜索',
                    how: '将查询转换为向量，计算余弦相似度并返回TopK结果'
                },
                code: `<span class="comment"># backend/vector_store.py</span>
<span class="keyword">class</span> <span class="function">VectorStore</span>:
    <span class="keyword">def __init__</span>(<span class="keyword">self</span>, collection_name: str):
        <span class="keyword">self</span>.client = chromadb.Client()
        <span class="keyword">self</span>.collection = <span class="keyword">self</span>.client.get_or_create_collection(
            name=collection_name
        )
    
    <span class="keyword">async def</span> <span class="function">search</span>(<span class="keyword">self</span>, query: str, limit: int = <span class="number">5</span>):
        results = <span class="keyword">self</span>.collection.query(
            query_texts=[query],
            n_results=limit,
            include=[<span class="string">"documents"</span>, <span class="string">"distances"</span>, <span class="string">"metadatas"</span>]
        )
        
        <span class="keyword">return</span> <span class="keyword">self</span>._format_results(results)`,
                runtime: {
                    status: '搜索完成',
                    metrics: {
                        '搜索维度': '384维',
                        '文档数量': '1,247个',
                        '相似度': '0.85+'
                    }
                }
            },
            'model-r1-direct': {
                title: '⚡ 模型R1直接',
                concept: {
                    why: '对于简单查询提供快速直接回答',
                    what: '使用轻量级模型处理无需检索的查询',
                    how: '绕过向量搜索，直接生成回答以提高响应速度'
                },
                code: `<span class="comment"># backend/direct_responder.py</span>
<span class="keyword">class</span> <span class="function">DirectResponder</span>:
    <span class="keyword">def __init__</span>(<span class="keyword">self</span>, model_client):
        <span class="keyword">self</span>.client = model_client
        <span class="keyword">self</span>.quick_responses = {
            <span class="string">"你好"</span>: <span class="string">"你好！我是课程助手，有什么可以帮助你的吗？"</span>,
            <span class="string">"谢谢"</span>: <span class="string">"不客气！很高兴能帮助到你。"</span>
        }
    
    <span class="keyword">async def</span> <span class="function">respond</span>(<span class="keyword">self</span>, query: str):
        <span class="comment"># 检查快速回复</span>
        <span class="keyword">for</span> key, response <span class="keyword">in</span> <span class="keyword">self</span>.quick_responses.items():
            <span class="keyword">if</span> key <span class="keyword">in</span> query:
                <span class="keyword">return</span> response
        
        <span class="comment"># 使用模型生成</span>
        <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">self</span>.client.quick_generate(query)`,
                runtime: {
                    status: '快速响应',
                    metrics: {
                        '响应类型': '直接回答',
                        '处理时间': '12ms',
                        '缓存命中': '是'
                    }
                }
            },
            'model-switch': {
                title: '🔄 模型切换',
                concept: {
                    why: '根据查询复杂度和性能要求选择合适的模型',
                    what: '在不同AI模型之间进行智能切换',
                    how: '基于查询分析结果选择最适合的模型进行处理'
                },
                code: `<span class="comment"># backend/model_switcher.py</span>
<span class="keyword">class</span> <span class="function">ModelSwitcher</span>:
    <span class="keyword">def __init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.models = {
            <span class="string">"fast"</span>: <span class="string">"claude-3-haiku"</span>,
            <span class="string">"balanced"</span>: <span class="string">"claude-3-sonnet"</span>,
            <span class="string">"advanced"</span>: <span class="string">"claude-3-opus"</span>
        }
    
    <span class="keyword">def</span> <span class="function">select_model</span>(<span class="keyword">self</span>, query_complexity: str, context_length: int):
        <span class="keyword">if</span> context_length > <span class="number">10000</span> <span class="keyword">or</span> query_complexity == <span class="string">"high"</span>:
            <span class="keyword">return</span> <span class="keyword">self</span>.models[<span class="string">"advanced"</span>]
        <span class="keyword">elif</span> query_complexity == <span class="string">"medium"</span>:
            <span class="keyword">return</span> <span class="keyword">self</span>.models[<span class="string">"balanced"</span>]
        <span class="keyword">else</span>:
            <span class="keyword">return</span> <span class="keyword">self</span>.models[<span class="string">"fast"</span>]`,
                runtime: {
                    status: '模型选择',
                    metrics: {
                        '当前模型': 'claude-3-sonnet',
                        '切换原因': '查询复杂度',
                        '选择时间': '3ms'
                    }
                }
            },
            'result-integrate': {
                title: '🔗 结果整合',
                concept: {
                    why: '将检索结果和AI生成内容整合为连贯回答',
                    what: '合并向量搜索结果和模型生成的回答',
                    how: '使用模板和规则将多个信息源整合为最终响应'
                },
                code: `<span class="comment"># backend/result_integrator.py</span>
<span class="keyword">class</span> <span class="function">ResultIntegrator</span>:
    <span class="keyword">def</span> <span class="function">integrate</span>(<span class="keyword">self</span>, search_results: list, ai_response: str):
        <span class="comment"># 提取相关文档</span>
        sources = []
        <span class="keyword">for</span> result <span class="keyword">in</span> search_results:
            <span class="keyword">if</span> result[<span class="string">"distance"</span>] < <span class="number">0.3</span>:  <span class="comment"># 高相似度</span>
                sources.append({
                    <span class="string">"content"</span>: result[<span class="string">"document"</span>],
                    <span class="string">"metadata"</span>: result[<span class="string">"metadata"</span>]
                })
        
        <span class="comment"># 整合回答</span>
        integrated_response = {
            <span class="string">"answer"</span>: ai_response,
            <span class="string">"sources"</span>: sources,
            <span class="string">"confidence"</span>: <span class="keyword">self</span>._calculate_confidence(sources)
        }
        
        <span class="keyword">return</span> integrated_response`,
                runtime: {
                    status: '整合完成',
                    metrics: {
                        '引用源数': '3个',
                        '置信度': '92%',
                        '响应长度': '247字'
                    }
                }
            },
            'final-response': {
                title: '📤 最终响应',
                concept: {
                    why: '向用户返回格式化的最终回答',
                    what: '整理并格式化回答内容，准备返回给用户',
                    how: '添加元数据，格式化输出，记录响应日志'
                },
                code: `<span class="comment"># backend/response_formatter.py</span>
<span class="keyword">class</span> <span class="function">ResponseFormatter</span>:
    <span class="keyword">def</span> <span class="function">format</span>(<span class="keyword">self</span>, integrated_result: dict, query_info: dict):
        response = {
            <span class="string">"answer"</span>: integrated_result[<span class="string">"answer"</span>],
            <span class="string">"sources"</span>: integrated_result[<span class="string">"sources"</span>],
            <span class="string">"metadata"</span>: {
                <span class="string">"query_id"</span>: query_info[<span class="string">"id"</span>],
                <span class="string">"processing_time"</span>: query_info[<span class="string">"duration"</span>],
                <span class="string">"confidence"</span>: integrated_result[<span class="string">"confidence"</span>],
                <span class="string">"timestamp"</span>: datetime.now().isoformat()
            }
        }
        
        <span class="comment"># 记录日志</span>
        logger.info(f<span class="string">"响应已生成: {response['metadata']['query_id']}"</span>)
        
        <span class="keyword">return</span> response`,
                runtime: {
                    status: '响应就绪',
                    metrics: {
                        '总处理时间': '1.8s',
                        '响应状态': '200 OK',
                        '字符数': '247个'
                    }
                }
            }
        };
        
        // 显示运行态节点详情
        function showRuntimeNodeDetail(nodeId) {
            // 优先使用运行态特定的节点数据
            const detail = runtimeNodeDetails[nodeId] || nodeDetails[nodeId];
            if (detail) {
                showNodeDetail(nodeId, detail);
            }
        }
        
        // 显示管理态节点详情
        function showManageNodeDetail(nodeId) {
            // 优先使用管理态特定的节点数据
            const detail = manageNodeDetails[nodeId] || nodeDetails[nodeId];
            if (detail) {
                showNodeDetail(nodeId, detail);
            }
        }

        // 执行步骤
        function runSteps(steps) {
            let index = 0;
            
            function processNext() {
                if (index >= steps.length) {
                    isProcessing = false;
                    document.getElementById('status-text').textContent = '演示完成';
                    updateProgress(100);
                    return;
                }
                
                const step = steps[index];
                const node = document.getElementById(step.node);
                
                if (node) {
                    // 激活节点
                    node.classList.add('active');
                    
                    // 更新进度
                    updateProgress((index + 1) / steps.length * 100);
                    
                    // 添加日志
                    addLog(`处理：${step.node.replace('-node', '')}`);
                }
                
                // 标记为完成并继续
                setTimeout(() => {
                    if (node) {
                        node.classList.remove('active');
                        node.classList.add('completed');
                    }
                    index++;
                    processNext();
                }, step.delay);
            }
            
            processNext();
        }

        // 重置演示
        function resetDemo() {
            isProcessing = false;
            currentStep = 0;
            
            // 重置所有节点
            resetNodes();
            
            // 重置进度
            updateProgress(0);
            
            // 重置状态
            document.getElementById('status-text').textContent = '准备就绪';
            
            // 清空日志
            document.getElementById('runtime-log').innerHTML = '[系统] 已重置';
        }

        // 重置节点状态
        function resetNodes() {
            document.querySelectorAll('.flow-node').forEach(node => {
                node.classList.remove('active', 'completed');
            });
            document.querySelectorAll('.pipeline-path').forEach(path => {
                path.classList.remove('active');
            });
        }

        // 更新进度条
        function updateProgress(percent) {
            document.getElementById('progress-fill').style.width = percent + '%';
        }

        // 更新指标
        function updateMetrics() {
            document.getElementById('time-metric').textContent = '0.0s';
            document.getElementById('docs-metric').textContent = '0';
            document.getElementById('vectors-metric').textContent = '384';
            document.getElementById('similarity-metric').textContent = '0%';
        }

        // 添加日志
        function addLog(message) {
            const logEl = document.getElementById('runtime-log');
            const time = new Date().toLocaleTimeString();
            const logEntry = `[${time}] ${message}\n`;
            logEl.textContent = logEntry + logEl.textContent;
            
            // 限制日志长度
            const lines = logEl.textContent.split('\n');
            if (lines.length > 10) {
                logEl.textContent = lines.slice(0, 10).join('\n');
            }
        }

        // 添加提示
        function addTooltips() {
            // 这里可以添加更多交互提示
        }
    </script>
</body>
</html>